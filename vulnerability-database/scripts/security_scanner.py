#!/usr/bin/env python3
"""
Security Scanner for Vulnerability Database
Automated scanning system based on Session Foundation security audit findings
"""

import json
import os
import re
import sys
import argparse
import requests
from datetime import datetime
from typing import Dict, List, Any, Optional
import subprocess
from pathlib import Path

class SecurityScanner:
    """Main security scanner class"""
    
    def __init__(self, vulnerability_db_path: str):
        """Initialize scanner with vulnerability database"""
        self.vulnerability_db_path = vulnerability_db_path
        self.vulnerabilities = self._load_vulnerability_database()
        self.scan_results = []
        
    def _load_vulnerability_database(self) -> Dict[str, Any]:
        """Load vulnerability database from JSON file"""
        try:
            with open(self.vulnerability_db_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"Error loading vulnerability database: {e}")
            sys.exit(1)
    
    def scan_repository(self, repo_path: str, repo_name: str = None) -> Dict[str, Any]:
        """Scan a repository for vulnerabilities"""
        if not repo_name:
            repo_name = os.path.basename(repo_path)
            
        print(f"Scanning repository: {repo_name}")
        
        scan_result = {
            "repository": repo_name,
            "scan_timestamp": datetime.now().isoformat(),
            "vulnerabilities_found": [],
            "total_issues": 0,
            "severity_counts": {"critical": 0, "high": 0, "medium": 0, "low": 0},
            "compliance_impact": {"standards": set(), "max_risk_score": 0}
        }
        
        # Scan for each vulnerability pattern
        for vuln in self.vulnerabilities["vulnerabilities"]:
            issues = self._scan_for_vulnerability(repo_path, vuln)
            if issues:
                vuln_result = {
                    "vulnerability_id": vuln["id"],
                    "name": vuln["name"],
                    "category": vuln["category"],
                    "severity": vuln["severity"],
                    "cvss_score": vuln["cvss_score"],
                    "issues": issues,
                    "remediation_summary": vuln["remediation"]["summary"],
                    "estimated_fix_time": vuln["remediation"]["estimated_fix_time"]
                }
                scan_result["vulnerabilities_found"].append(vuln_result)
                scan_result["severity_counts"][vuln["severity"]] += len(issues)
                scan_result["total_issues"] += len(issues)
                
                # Track compliance impact
                if "compliance_impact" in vuln:
                    scan_result["compliance_impact"]["standards"].update(
                        vuln["compliance_impact"]["standards"]
                    )
                    scan_result["compliance_impact"]["max_risk_score"] = max(
                        scan_result["compliance_impact"]["max_risk_score"],
                        vuln["compliance_impact"]["risk_score"]
                    )
        
        # Convert set to list for JSON serialization
        scan_result["compliance_impact"]["standards"] = list(
            scan_result["compliance_impact"]["standards"]
        )
        
        self.scan_results.append(scan_result)
        return scan_result
    
    def _scan_for_vulnerability(self, repo_path: str, vulnerability: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan for a specific vulnerability pattern"""
        issues = []
        detection_patterns = vulnerability.get("detection_patterns", {})
        
        # Scan code patterns
        if "code_patterns" in detection_patterns:
            issues.extend(self._scan_code_patterns(repo_path, detection_patterns["code_patterns"]))
        
        # Scan config patterns
        if "config_patterns" in detection_patterns:
            issues.extend(self._scan_config_patterns(repo_path, detection_patterns["config_patterns"]))
        
        return issues
    
    def _scan_code_patterns(self, repo_path: str, patterns: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan for code-based vulnerability patterns"""
        issues = []
        
        for pattern in patterns:
            language = pattern.get("language", "")
            regex_pattern = pattern.get("regex", "")
            
            if not regex_pattern:
                continue
                
            # Find files matching the language
            file_extensions = self._get_file_extensions_for_language(language)
            
            for ext in file_extensions:
                for file_path in Path(repo_path).rglob(f"*.{ext}"):
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                            
                        matches = re.finditer(regex_pattern, content, re.MULTILINE | re.IGNORECASE)
                        for match in matches:
                            line_number = content[:match.start()].count('\n') + 1
                            issues.append({
                                "file": str(file_path.relative_to(repo_path)),
                                "line": line_number,
                                "pattern": pattern["pattern"],
                                "match": match.group(0)[:100],  # Truncate long matches
                                "type": "code_pattern"
                            })
                    except Exception as e:
                        # Skip files that can't be read
                        continue
        
        return issues
    
    def _scan_config_patterns(self, repo_path: str, patterns: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan for configuration-based vulnerability patterns"""
        issues = []
        
        for pattern in patterns:
            file_pattern = pattern.get("file_pattern", "")
            content_pattern = pattern.get("content_pattern", "")
            
            if not file_pattern or not content_pattern:
                continue
            
            # Convert glob pattern to regex for file matching
            if file_pattern.startswith("*."):
                extension = file_pattern[2:]
                matching_files = list(Path(repo_path).rglob(f"*.{extension}"))
            elif "*" in file_pattern:
                matching_files = list(Path(repo_path).rglob(file_pattern))
            else:
                matching_files = list(Path(repo_path).rglob(file_pattern))
            
            for file_path in matching_files:
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                    
                    matches = re.finditer(content_pattern, content, re.MULTILINE | re.IGNORECASE)
                    for match in matches:
                        line_number = content[:match.start()].count('\n') + 1
                        issues.append({
                            "file": str(file_path.relative_to(repo_path)),
                            "line": line_number,
                            "pattern": content_pattern,
                            "match": match.group(0)[:100],
                            "type": "config_pattern"
                        })
                except Exception as e:
                    continue
        
        return issues
    
    def _get_file_extensions_for_language(self, language: str) -> List[str]:
        """Get file extensions for a programming language"""
        language_extensions = {
            "javascript": ["js", "jsx", "ts", "tsx"],
            "python": ["py"],
            "java": ["java"],
            "php": ["php"],
            "solidity": ["sol"],
            "html": ["html", "htm"],
            "xml": ["xml"],
            "yaml": ["yml", "yaml"],
            "json": ["json"]
        }
        return language_extensions.get(language.lower(), [])
    
    def generate_report(self, output_format: str = "json") -> str:
        """Generate scan report in specified format"""
        if output_format.lower() == "json":
            return json.dumps(self.scan_results, indent=2)
        elif output_format.lower() == "html":
            return self._generate_html_report()
        else:
            return self._generate_text_report()
    
    def _generate_html_report(self) -> str:
        """Generate HTML vulnerability report"""
        html = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Security Vulnerability Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background-color: #f0f0f0; padding: 20px; border-radius: 5px; }
                .repo { margin: 20px 0; border: 1px solid #ddd; padding: 15px; border-radius: 5px; }
                .vulnerability { margin: 10px 0; padding: 10px; border-left: 4px solid #ccc; }
                .critical { border-left-color: #d32f2f; }
                .high { border-left-color: #f57c00; }
                .medium { border-left-color: #fbc02d; }
                .low { border-left-color: #388e3c; }
                .issue { margin: 5px 0; padding: 5px; background-color: #f9f9f9; }
                .stats { display: flex; gap: 20px; margin: 10px 0; }
                .stat { padding: 10px; background-color: #e3f2fd; border-radius: 3px; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Security Vulnerability Report</h1>
                <p>Generated on: """ + datetime.now().strftime("%Y-%m-%d %H:%M:%S") + """</p>
                <p>Based on Session Foundation Security Audit Findings</p>
            </div>
        """
        
        for result in self.scan_results:
            html += f"""
            <div class="repo">
                <h2>Repository: {result['repository']}</h2>
                <div class="stats">
                    <div class="stat">Total Issues: {result['total_issues']}</div>
                    <div class="stat">Critical: {result['severity_counts']['critical']}</div>
                    <div class="stat">High: {result['severity_counts']['high']}</div>
                    <div class="stat">Medium: {result['severity_counts']['medium']}</div>
                    <div class="stat">Low: {result['severity_counts']['low']}</div>
                </div>
                <p><strong>Compliance Standards Affected:</strong> {', '.join(result['compliance_impact']['standards'])}</p>
                <p><strong>Maximum Risk Score:</strong> {result['compliance_impact']['max_risk_score']}/10</p>
            """
            
            for vuln in result['vulnerabilities_found']:
                html += f"""
                <div class="vulnerability {vuln['severity']}">
                    <h3>{vuln['name']} ({vuln['vulnerability_id']})</h3>
                    <p><strong>Severity:</strong> {vuln['severity'].upper()} (CVSS: {vuln['cvss_score']})</p>
                    <p><strong>Category:</strong> {vuln['category'].replace('_', ' ').title()}</p>
                    <p><strong>Remediation:</strong> {vuln['remediation_summary']}</p>
                    <p><strong>Estimated Fix Time:</strong> {vuln['estimated_fix_time']}</p>
                    <h4>Issues Found:</h4>
                """
                
                for issue in vuln['issues']:
                    html += f"""
                    <div class="issue">
                        <strong>File:</strong> {issue['file']} (Line {issue['line']})<br>
                        <strong>Pattern:</strong> {issue['pattern']}<br>
                        <strong>Match:</strong> <code>{issue['match']}</code>
                    </div>
                    """
                
                html += "</div>"
            
            html += "</div>"
        
        html += """
        </body>
        </html>
        """
        return html
    
    def _generate_text_report(self) -> str:
        """Generate plain text vulnerability report"""
        report = "SECURITY VULNERABILITY REPORT\n"
        report += "=" * 50 + "\n"
        report += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        report += f"Source: Session Foundation Security Audit Findings\n\n"
        
        for result in self.scan_results:
            report += f"Repository: {result['repository']}\n"
            report += "-" * 30 + "\n"
            report += f"Total Issues: {result['total_issues']}\n"
            report += f"Critical: {result['severity_counts']['critical']}, "
            report += f"High: {result['severity_counts']['high']}, "
            report += f"Medium: {result['severity_counts']['medium']}, "
            report += f"Low: {result['severity_counts']['low']}\n"
            report += f"Compliance Standards: {', '.join(result['compliance_impact']['standards'])}\n"
            report += f"Max Risk Score: {result['compliance_impact']['max_risk_score']}/10\n\n"
            
            for vuln in result['vulnerabilities_found']:
                report += f"  [{vuln['severity'].upper()}] {vuln['name']} ({vuln['vulnerability_id']})\n"
                report += f"  CVSS Score: {vuln['cvss_score']}\n"
                report += f"  Category: {vuln['category'].replace('_', ' ').title()}\n"
                report += f"  Issues: {len(vuln['issues'])}\n"
                report += f"  Fix Time: {vuln['estimated_fix_time']}\n"
                report += f"  Remediation: {vuln['remediation_summary']}\n\n"
        
        return report

def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(description="Security vulnerability scanner")
    parser.add_argument("--vulnerability-db", required=True, 
                        help="Path to vulnerability database JSON file")
    parser.add_argument("--repo-path", required=True,
                        help="Path to repository to scan")
    parser.add_argument("--repo-name", 
                        help="Name of repository (default: directory name)")
    parser.add_argument("--output-format", choices=["json", "html", "text"], 
                        default="json", help="Output format")
    parser.add_argument("--output-file", 
                        help="Output file (default: stdout)")
    
    args = parser.parse_args()
    
    # Initialize scanner
    scanner = SecurityScanner(args.vulnerability_db)
    
    # Scan repository
    scan_result = scanner.scan_repository(args.repo_path, args.repo_name)
    
    # Generate report
    report = scanner.generate_report(args.output_format)
    
    # Output report
    if args.output_file:
        with open(args.output_file, 'w') as f:
            f.write(report)
        print(f"Report written to {args.output_file}")
    else:
        print(report)
    
    # Exit with appropriate code
    sys.exit(0 if scan_result["total_issues"] == 0 else 1)

if __name__ == "__main__":
    main()