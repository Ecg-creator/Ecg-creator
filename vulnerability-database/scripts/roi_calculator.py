#!/usr/bin/env python3
"""
ROI Calculator for Security Investment
Calculates return on investment for proactive vulnerability management
"""

import json
import os
import sys
import argparse
from datetime import datetime
from typing import Dict, List, Any
import glob

class SecurityROICalculator:
    """Calculates ROI metrics for security investments"""
    
    def __init__(self):
        self.cost_models = {
            "data_breach_average_cost": 4240000,  # USD - IBM 2023 report
            "compliance_violation_penalty": 500000,  # Average regulatory penalty
            "incident_response_cost": 50000,  # Per incident
            "manual_security_assessment_cost": 15000,  # Per assessment
            "developer_hourly_rate": 75,  # USD per hour
            "security_specialist_hourly_rate": 125,  # USD per hour
            "business_disruption_hourly_cost": 5000,  # Per hour of downtime
        }
        
        self.vulnerability_risk_multipliers = {
            "critical": 1.0,
            "high": 0.7,
            "medium": 0.3,
            "low": 0.1
        }
        
        self.category_business_impact = {
            "session_management": 0.9,  # High business impact
            "network_security": 0.8,
            "smart_contract_security": 1.0,  # Maximum business impact
            "infrastructure_security": 0.7
        }
    
    def calculate_roi_metrics(self, scan_results_dir: str) -> Dict[str, Any]:
        """Calculate comprehensive ROI metrics"""
        # Load all scan results
        repositories_data = self._load_all_scan_results(scan_results_dir)
        
        if not repositories_data:
            return {"error": "No scan results found"}
        
        # Calculate metrics
        total_vulnerabilities = self._count_total_vulnerabilities(repositories_data)
        potential_losses = self._calculate_potential_losses(repositories_data)
        prevention_savings = self._calculate_prevention_savings(repositories_data)
        implementation_costs = self._calculate_implementation_costs(repositories_data)
        operational_savings = self._calculate_operational_savings(repositories_data)
        
        # Calculate ROI
        total_benefits = prevention_savings + operational_savings
        total_costs = implementation_costs
        roi_percentage = ((total_benefits - total_costs) / total_costs * 100) if total_costs > 0 else 0
        
        # Calculate payback period (months)
        monthly_savings = (prevention_savings + operational_savings) / 12
        payback_months = (total_costs / monthly_savings) if monthly_savings > 0 else float('inf')
        
        roi_metrics = {
            "analysis_timestamp": datetime.now().isoformat(),
            "portfolio_overview": {
                "total_repositories": len(repositories_data),
                "total_vulnerabilities": total_vulnerabilities,
                "vulnerability_breakdown": self._get_vulnerability_breakdown(repositories_data)
            },
            "financial_analysis": {
                "potential_annual_losses": potential_losses,
                "prevention_savings": prevention_savings,
                "operational_savings": operational_savings,
                "implementation_costs": implementation_costs,
                "total_benefits": total_benefits,
                "total_costs": total_costs,
                "net_benefit": total_benefits - total_costs,
                "roi_percentage": roi_percentage,
                "payback_months": min(payback_months, 60)  # Cap at 5 years
            },
            "risk_metrics": {
                "business_risk_score": self._calculate_business_risk_score(repositories_data),
                "compliance_risk_assessment": self._assess_compliance_risk(repositories_data),
                "security_maturity_score": self._calculate_security_maturity(repositories_data)
            },
            "competitive_advantages": self._identify_competitive_advantages(repositories_data),
            "recommendations": self._generate_roi_recommendations(repositories_data, roi_percentage)
        }
        
        return roi_metrics
    
    def _load_all_scan_results(self, results_dir: str) -> List[Dict[str, Any]]:
        """Load all scan results from directory"""
        repositories_data = []
        results_pattern = os.path.join(results_dir, "**/scan-results-*.json")
        result_files = glob.glob(results_pattern, recursive=True)
        
        for result_file in result_files:
            try:
                with open(result_file, 'r') as f:
                    data = json.load(f)
                    if isinstance(data, list) and len(data) > 0:
                        repositories_data.append(data[0])
            except Exception as e:
                print(f"Error loading {result_file}: {e}")
                continue
        
        return repositories_data
    
    def _count_total_vulnerabilities(self, repositories_data: List[Dict[str, Any]]) -> int:
        """Count total vulnerabilities across all repositories"""
        return sum(repo.get("total_issues", 0) for repo in repositories_data)
    
    def _get_vulnerability_breakdown(self, repositories_data: List[Dict[str, Any]]) -> Dict[str, int]:
        """Get vulnerability breakdown by severity"""
        breakdown = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        
        for repo in repositories_data:
            severity_counts = repo.get("severity_counts", {})
            for severity, count in severity_counts.items():
                breakdown[severity] += count
        
        return breakdown
    
    def _calculate_potential_losses(self, repositories_data: List[Dict[str, Any]]) -> float:
        """Calculate potential annual losses from vulnerabilities"""
        total_potential_loss = 0
        
        for repo in repositories_data:
            repo_loss = 0
            severity_counts = repo.get("severity_counts", {})
            
            for severity, count in severity_counts.items():
                if count > 0:
                    # Calculate probability of exploitation
                    exploitation_probability = self.vulnerability_risk_multipliers.get(severity, 0.1)
                    
                    # Base loss calculation
                    if severity == "critical":
                        base_loss = self.cost_models["data_breach_average_cost"]
                    elif severity == "high":
                        base_loss = self.cost_models["compliance_violation_penalty"]
                    elif severity == "medium":
                        base_loss = self.cost_models["incident_response_cost"]
                    else:  # low
                        base_loss = self.cost_models["incident_response_cost"] * 0.2
                    
                    # Apply category multipliers
                    category_multiplier = 1.0
                    for vuln in repo.get("vulnerabilities_found", []):
                        if vuln.get("severity") == severity:
                            category = vuln.get("category", "")
                            category_multiplier = max(category_multiplier, 
                                                    self.category_business_impact.get(category, 0.5))
                    
                    repo_loss += base_loss * exploitation_probability * count * category_multiplier
            
            total_potential_loss += repo_loss
        
        return total_potential_loss
    
    def _calculate_prevention_savings(self, repositories_data: List[Dict[str, Any]]) -> float:
        """Calculate savings from preventing security incidents"""
        # Assume proactive vulnerability management prevents 85% of potential incidents
        prevention_rate = 0.85
        potential_losses = self._calculate_potential_losses(repositories_data)
        return potential_losses * prevention_rate
    
    def _calculate_implementation_costs(self, repositories_data: List[Dict[str, Any]]) -> float:
        """Calculate costs to implement vulnerability fixes"""
        total_cost = 0
        
        for repo in repositories_data:
            for vuln in repo.get("vulnerabilities_found", []):
                estimated_time = vuln.get("estimated_fix_time", "2 hours")
                
                # Parse time estimate
                hours = self._parse_time_estimate(estimated_time)
                
                # Calculate cost based on severity (different skill levels required)
                severity = vuln.get("severity", "medium")
                if severity in ["critical", "high"]:
                    hourly_rate = self.cost_models["security_specialist_hourly_rate"]
                else:
                    hourly_rate = self.cost_models["developer_hourly_rate"]
                
                issue_count = len(vuln.get("issues", []))
                total_cost += hours * hourly_rate * issue_count
        
        # Add overhead for project management, testing, deployment (25%)
        total_cost *= 1.25
        
        return total_cost
    
    def _calculate_operational_savings(self, repositories_data: List[Dict[str, Any]]) -> float:
        """Calculate operational savings from automated security processes"""
        # Savings from automated vs manual security assessments
        num_repos = len(repositories_data)
        manual_assessment_cost = self.cost_models["manual_security_assessment_cost"]
        annual_assessment_frequency = 4  # Quarterly assessments
        
        manual_cost = num_repos * manual_assessment_cost * annual_assessment_frequency
        
        # Automated system reduces assessment costs by 70%
        automation_savings = manual_cost * 0.70
        
        # Additional savings from faster incident response
        total_vulnerabilities = self._count_total_vulnerabilities(repositories_data)
        if total_vulnerabilities > 0:
            # Assume faster detection/response saves 4 hours per incident
            response_time_savings = (total_vulnerabilities * 0.1 * 4 * 
                                   self.cost_models["business_disruption_hourly_cost"])
        else:
            response_time_savings = 0
        
        return automation_savings + response_time_savings
    
    def _parse_time_estimate(self, time_str: str) -> float:
        """Parse time estimate string to hours"""
        time_str = time_str.lower()
        
        if "hour" in time_str:
            # Extract numbers and calculate average if range
            numbers = [float(x) for x in time_str.split() if x.replace('-', '').replace('.', '').isdigit()]
            if len(numbers) == 2:
                return (numbers[0] + numbers[1]) / 2
            elif len(numbers) == 1:
                return numbers[0]
        elif "day" in time_str:
            numbers = [float(x) for x in time_str.split() if x.replace('-', '').replace('.', '').isdigit()]
            if len(numbers) >= 1:
                return numbers[0] * 8  # 8 hours per day
        
        return 2.0  # Default to 2 hours
    
    def _calculate_business_risk_score(self, repositories_data: List[Dict[str, Any]]) -> float:
        """Calculate overall business risk score"""
        if not repositories_data:
            return 0
        
        total_risk = 0
        for repo in repositories_data:
            compliance_impact = repo.get("compliance_impact", {})
            risk_score = compliance_impact.get("max_risk_score", 0)
            issue_count = repo.get("total_issues", 0)
            
            # Weight by number of issues
            weighted_risk = risk_score * (1 + (issue_count / 100))
            total_risk += weighted_risk
        
        return min(total_risk / len(repositories_data), 10.0)
    
    def _assess_compliance_risk(self, repositories_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Assess compliance risk across portfolios"""
        all_standards = set()
        high_risk_standards = set()
        
        for repo in repositories_data:
            compliance_impact = repo.get("compliance_impact", {})
            standards = compliance_impact.get("standards", [])
            risk_score = compliance_impact.get("max_risk_score", 0)
            
            all_standards.update(standards)
            if risk_score >= 7:
                high_risk_standards.update(standards)
        
        return {
            "total_standards_affected": len(all_standards),
            "high_risk_standards": list(high_risk_standards),
            "compliance_standards": list(all_standards),
            "risk_level": "HIGH" if len(high_risk_standards) > 0 else "MEDIUM" if len(all_standards) > 0 else "LOW"
        }
    
    def _calculate_security_maturity(self, repositories_data: List[Dict[str, Any]]) -> float:
        """Calculate security maturity score (0-10)"""
        if not repositories_data:
            return 5.0
        
        total_issues = self._count_total_vulnerabilities(repositories_data)
        vulnerability_breakdown = self._get_vulnerability_breakdown(repositories_data)
        
        # Start with base score
        maturity_score = 7.0
        
        # Reduce score based on critical/high vulnerabilities
        critical_penalty = vulnerability_breakdown["critical"] * 0.5
        high_penalty = vulnerability_breakdown["high"] * 0.3
        
        maturity_score -= (critical_penalty + high_penalty)
        
        # Bonus for proactive scanning implementation
        maturity_score += 1.0
        
        return max(min(maturity_score, 10.0), 0.0)
    
    def _identify_competitive_advantages(self, repositories_data: List[Dict[str, Any]]) -> List[Dict[str, str]]:
        """Identify competitive advantages from security investment"""
        advantages = []
        
        total_issues = self._count_total_vulnerabilities(repositories_data)
        vulnerability_breakdown = self._get_vulnerability_breakdown(repositories_data)
        
        if total_issues > 0:
            advantages.extend([
                {
                    "advantage": "Proactive Security Posture",
                    "description": "Early detection and remediation of vulnerabilities before exploitation",
                    "business_value": "Prevents costly security incidents and data breaches"
                },
                {
                    "advantage": "Regulatory Compliance Assurance",
                    "description": "Automated compliance monitoring reduces audit risks",
                    "business_value": "Avoids regulatory penalties and maintains customer trust"
                },
                {
                    "advantage": "Reduced Operational Risk",
                    "description": "Systematic vulnerability management reduces business disruption",
                    "business_value": "Maintains service availability and customer satisfaction"
                }
            ])
        
        if vulnerability_breakdown["critical"] == 0 and vulnerability_breakdown["high"] <= 5:
            advantages.append({
                "advantage": "Enterprise Security Leadership",
                "description": "Low critical/high vulnerability count demonstrates security excellence",
                "business_value": "Competitive differentiation in enterprise sales"
            })
        
        advantages.append({
            "advantage": "Automated Security Operations",
            "description": "Continuous security monitoring and reporting capabilities",
            "business_value": "Reduced manual security assessment costs and faster response times"
        })
        
        return advantages
    
    def _generate_roi_recommendations(self, repositories_data: List[Dict[str, Any]], roi_percentage: float) -> List[Dict[str, str]]:
        """Generate ROI-focused recommendations"""
        recommendations = []
        
        vulnerability_breakdown = self._get_vulnerability_breakdown(repositories_data)
        
        if roi_percentage > 200:
            recommendations.append({
                "priority": "HIGH",
                "category": "Investment Expansion",
                "recommendation": "Excellent ROI justifies expanding security automation to additional repositories",
                "expected_benefit": "Scale benefits across entire portfolio"
            })
        elif roi_percentage > 100:
            recommendations.append({
                "priority": "MEDIUM", 
                "category": "Process Optimization",
                "recommendation": "Good ROI supports continued investment with process refinement",
                "expected_benefit": "Optimize implementation efficiency"
            })
        else:
            recommendations.append({
                "priority": "HIGH",
                "category": "Strategy Review", 
                "recommendation": "Review implementation strategy to improve ROI",
                "expected_benefit": "Identify cost reduction opportunities"
            })
        
        if vulnerability_breakdown["critical"] > 0:
            recommendations.append({
                "priority": "CRITICAL",
                "category": "Risk Mitigation",
                "recommendation": "Immediate remediation of critical vulnerabilities required",
                "expected_benefit": "Prevent potential security incidents and associated costs"
            })
        
        recommendations.append({
            "priority": "MEDIUM",
            "category": "Continuous Improvement",
            "recommendation": "Implement regular security metrics review and reporting",
            "expected_benefit": "Maintain security posture and demonstrate ongoing value"
        })
        
        return recommendations

def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(description="Calculate security investment ROI")
    parser.add_argument("--scan-results", required=True,
                        help="Directory containing scan results")
    parser.add_argument("--output", required=True,
                        help="Output JSON file for ROI analysis")
    
    args = parser.parse_args()
    
    # Calculate ROI metrics
    calculator = SecurityROICalculator()
    roi_metrics = calculator.calculate_roi_metrics(args.scan_results)
    
    # Write results to file
    with open(args.output, 'w') as f:
        json.dump(roi_metrics, f, indent=2)
    
    print(f"ROI analysis completed: {args.output}")
    
    if "error" not in roi_metrics:
        print(f"ROI: {roi_metrics['financial_analysis']['roi_percentage']:.1f}%")
        print(f"Payback: {roi_metrics['financial_analysis']['payback_months']:.1f} months")
        print(f"Net Benefit: ${roi_metrics['financial_analysis']['net_benefit']:,.2f}")

if __name__ == "__main__":
    main()